# Создание ROS Publisher с использованием rospy

Самое время познакомиться с возможностями написания узлов на языке Python2. В качестве основы можно посмотреть офф страницу о [написании узлов](http://wiki.ros.org/rospy_tutorials/Tutorials/WritingPublisherSubscriber).

Также можно добавить к полезным ссылкам [API rospy](http://docs.ros.org/api/rospy/html/) и ссылку на общее описание [Subscribers and Publishers](http://wiki.ros.org/rospy/Overview/Publishers%20and%20Subscribers).

Для начала, импортируем основной модуль `rospy` и модуль сообщения типа `std_msgs/String`. 

```python
import rospy
from std_msgs.msg import String
```
После этого необходимо зарегистрировать узел в системе ROS, а также зарегистрировать топик на публикацию с указанием имени, типа сообщения для топика и размера очереди. Очередь нужна для сохранения сообщений, если узел публикует сообщения часто, при этом низкоуровневая передача сообщений работает медленнее или с задержками. При переполнении очереди отправляются наиболее актуальные данные.

```python
rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
```

> При регистрации узла функцией `init_node()` у конструктора есть флаг `anonymous`, который отключен по-умолчанию. Так при включении этого флага
```python
rospy.init_node('talker', anonymous=True)
```
к указанному имени узла добавляется суффикс, который делает узел уникальным в системе.

> У функции `rospy.Publisher()` есть флаг `latch`, который отключен по-умолчанию. Его включение добавляет следующее поведение: при отправке сообщений в топик сохраняется последнее отправленное сообщение и когда кто-нибудь подписался на этот топик - он сразу получает последнее сообщение из этого топика, даже если отправка была раньше, чем узел подписался на топик.

После остается только создать объект `Rate`, который используется для выдерживания частоты выполнения кода. В конструктор передается значение частоты в Гц.

```python
rate = rospy.Rate(1) # 1 Hz
```
На этом подготовка и создание необходимых объектов для простейшего узла готовы и пора перейти к основной логике программы.

В API ROS есть функция, которая сообщает о том, что система ROS завершила работу, именно ей и воспользуемся в качестве условия выхода `rospy.is_shutdown()`. Далее определим функцию с основной логикой узла для дальнейшего запуска.

```python
def talker():
    while not rospy.is_shutdown():
        # Сформируем сообщение, которое включает время
        hello_str = "hi =) %s" % rospy.get_time()
        # Вывод в терминал информации (содержание сообщения)
        rospy.loginfo(hello_str)
        # Публикация сообщения в топик
        pub.publish(hello_str)
        # Сон в соответствии с выдерживаемой частотой
        rate.sleep()
```

В случае с типом данных `std_msgs/String` можно просто передавать в функцию `publish()` данные сообщения. В случае с более комплексными данными рекомендуется сначала создавать объект сообщения, заполнять его и после публиковать.

```python
msg = String()
msg.data = hello_str

pub.publish(msg)
```
или
```python
msg = String(data.hello_str)

pub.publish(msg)
```
После этого можем запустить функцию узла (в ней находится вся логика). При этом заворачиваем в конструкцию `try-catch`, чтобы обработать прерывание (нажатием Стоп или Ctrl+C в терминале). 

```python
try:
    talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    pass
```

Общий код узла:
```python
#!/usr/bin/env python
import rospy
from std_msgs.msg import String

rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
rate = rospy.Rate(1) # 1 Hz

def talker():
    while not rospy.is_shutdown():
        # Сформируем сообщение, которое включает время
        hello_str = "hi =) %s" % rospy.get_time()
        # Вывод в терминал информации (содержание сообщения)
        rospy.loginfo(hello_str)
        # Публикация сообщения в топик
        pub.publish(hello_str)
        # Сон в соответствии с выдерживаемой частотой
        rate.sleep()

try:
    talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    pass
```

> Задачка по самостоятельной интеграции скрипта внутри пакета.
- Внутри пакета создать папку `scripts` (Python файлы считаются скриптами), в ней создать файл talker.py и в нем разместить код узла.
- Далее дать права на выполение с помощью команды `chmod +x talker.py`
- Попробовать запустить в системе ROS созданный узел, для ранее созданного пакета команда будет следующей:  
`rosrun study_pkg talker.py`
- Прим.: так как мы не задавали флаг анонимности в функции `rospy.init_node('talker')` (по-умолчанию там стоит `anonymous=False`), явно присваивать имя узла не требуется, оно будет такое, как было задано в функции `rospy.init_node()`
- Прим.: при возникновении каких-либо ошибок, они будут выведены в терминале 

## В результате
- Был создан узел, публикующий сообщения типа строки. Рассмотрено основное API пакета rospy.
